# 리스트(List)

리스트란 데이터를 순차적으로 저장하는 자료 구조이다. 리스트를 이용하여 나타내기 쉬운 것들의 예로는 학생 명부, 음반의 트랙 리스트, 수열 등이 있다.

## 구현

리스트는 크게 배열 리스트나 연결 리스트로 구현할 수 있으며, 연결 리스트는 또다시 단일 연결 리스트, 이중 연결 리스트, 원형 연결 리스트 등으로 구현할 수 있다. 여기서는 배열 리스트와 단일 연결 리스트를 구현해 볼 것이다.

> 여기에는 리스트 자료구조의 동작 원리만 정리해 놓았습니다. 상세한 구현 내용은 같이 있는 C# 소스 코드를 참고하세요.

### 리스트 인터페이스

배열 리스트와 연결 리스트는 내부 구현이 다르지만 아래의 `IList<TElem>`
인터페이스를 구현함으로써 일관된 사용법을 제공한다.

```cs
public interface IList<TElem>
{
  // 새 요소를 리스트의 맨 처음에 추가
  void AddFirst(TElem e);

  // 새 요소를 리스트의 맨 끝에 추가
  void AddLast(TElem e);

  // 새 요소를 리스트의 주어진 위치에 추가
  void AddAt(TElem e, int index);

  // 리스트에서 주어진 위치에 저장되어 있는 요소를 삭제
  TElem RemoveAt(int index);

  // 주어진 데이터가 리스트의 요소인지를 반환
  bool Contains(TElem e);

  // 리스트 비우기
  void Clear();

  // 리스트에 저장되어 있는 요소의 수를 반환
  int Count { get; }

  // 리스트가 비어있는지 확인
  bool IsEmpty { get; }

  // 리스트가 가득 찼는지 확인
  bool IsFull { get; }

  // 리스트상의 주어진 위치에 저장되어 있는 요소를 반환
  TElem this[int index] { get; }
}
```

### 배열 리스트의 구현

```cs
public class ArrayList<TElem> : IList<TElem>
{
  // 배열의 크기 고정
  private const MaxArraySize = 100;

  // 데이터가 저장될 배열
  private TElem[] array = new TElem[MaxArraySize];

  // IList<TElem> 인터페이스 구현 ...

  public override string ToString() { /* ... */ }
}
```

#### 요소 삽입 및 삭제

각각의 요소가 연속적으로 저장되는 배열의 특성 상, 리스트의 처음이나 중간에 새 요소를 삽입하기 위해서는 새 요소가 들어가기 위한 공간을 확보하기 위해 해당 위치와 그 뒤에 있는 모든 요소를 한 칸씩 뒤로 이동시킬 필요가 있다. 마찬가지 이유로 리스트의 처음이나 중간에 있던 기존 요소를 삭제한 후에는 그 빈 공간을 채우기 위해 그 뒤에 있는 모든 요소를 한 칸씩 앞으로 이동시켜야 한다.

**삽입 연산**

```
1.
+-----+-----+-----+-----+-----+-----+-----+
|  a  |  b  |  c  |  d  |  e  |     |     |
+-----+-----+-----+-----+-----+-----+-----+
            ↑                  ^ Count = 5
         +-----+
         |  X  |
         +-----+
2.
+-----+-----+-----+-----+-----+-----+-----+
|  a  |  b  | (c) |  c  |  d  |  e  |     |
+-----+-----+-----+-----+-----+-----+-----+
            ↑                  ^ Count = 5
         +-----+
         |  X  |
         +-----+
3.
+-----+-----+-----+-----+-----+-----+-----+
|  a  |  b  |  X  |  c  |  d  |  e  |     |
+-----+-----+-----+-----+-----+-----+-----+
                               Count = 6 ^
```

**삭제 연산**

```
1.
+-----+-----+-----+-----+-----+-----+-----+
|  a  |  b  | (c) |  d  |  e  |     |     |
+-----+-----+-----+-----+-----+-----+-----+
               ↓               ^ Count = 5
2.
+-----+-----+-----+-----+-----+-----+-----+
|  a  |  b  |  d  |  e  | (e) |     |     |
+-----+-----+-----+-----+-----+-----+-----+
                         ^ Count = 4
```

#### 리스트 요소에 액세스하기

배열은 랜덤 액세스가 가능한 자료 구조이므로, 배열 리스트의 임의의 요소에 액세스하는데 걸리는 시간은 일정하다.

### 연결 리스트의 구현

```cs
// 연결 리스트 노드
internal class ListNode<TElem>
{
  public ListNode(TElem data)
  {
    Data = data;
  }

  public TElem Data { get; set; }

  // 다음 노드에 대한 참조
  public ListNode<TElem> Next { get; set; } = null;
}

public class LinkedList<TElem> : IList<TElem>
{
  // 리스트의 맨 처음 노드에 대한 참조
  private ListNode<TElem> head = null;

  // IList<TElem> 인터페이스 구현 ...

  public override string ToString() { /* ... */ }
}
```

#### 요소 삽입 및 삭제

단일 연결 리스트는 각각의 요소를 연속적인 공간이 아니라 한 방향으로 연결된 노드 안에 저장하므로, 요소를 삽입하거나 삭제할 때는 해당 연산이 수행될 위치 바로 앞과 뒤에 있는 노드의 연결 상태만 변경하면 된다. 단 삽입/삭제 연산이 리스트의 맨 처음 위치에서 수행될 때는 리스트의 맨 첫 요소에 대한 참조도 그에 따라 적절히 변경해야 한다.

**리스트의 중간에 삽입**

```
1.
        +-----+     +-----+     +-----+
head -->|  a  |---->|  b  |---->|  c  |----//
        +-----+     +-----+     +-----+
                 ↑
              +-----+
              |  X  |----//
              +-----+
2.
        +-----+     +-----+     +-----+
head -->|  a  |---->|  b  |---->|  c  |----//
        +-----+     +-----+     +-----+
                       ↑
              +-----+  |
              |  X  |--+
              +-----+
3.
        +-----+     +-----+     +-----+
head -->|  a  |  X  |  b  |---->|  c  |----//
        +-----+     +-----+     +-----+
          |            ↑
          |   +-----+  |
          +-->|  X  |--+
              +-----+
```

**리스트의 처음에 삽입**

```
1.
        +-----+     +-----+     +-----+
head -->|  a  |---->|  b  |---->|  c  |----//
        +-----+     +-----+     +-----+
     ↑
  +-----+
  |  X  |----//
  +-----+
2.
        +-----+     +-----+     +-----+
head -->|  a  |---->|  b  |---->|  c  |----//
        +-----+     +-----+     +-----+
           ↑
  +-----+  |
  |  X  |--+
  +-----+
3.
        +-----+     +-----+     +-----+
head  X |  a  |---->|  b  |---->|  c  |----//
   |    +-----+     +-----+     +-----+
   ↓       ↑
  +-----+  |
  |  X  |--+
  +-----+
```

**리스트의 중간에 있는 요소를 삭제**

```
1.
        +-----+     +-----+     +-----+
head -->|  a  |---->|  b  |---->|  c  |----//
        +-----+     +-----+     +-----+
                       ↓
2.
        +-----+           +-----+
head -->|  a  |---------->|  c  |----//
        +-----+  +-----+  +-----+
                 |  b  |----->
                 +-----+
3.
        +-----+           +-----+
head -->|  a  |---------->|  c  |----//
        +-----+  +-----+  +-----+
                 |  b  |--//
                 +-----+
```

**리스트의 첫번째 요소를 삭제**

```
1.
        +-----+     +-----+     +-----+
head -->|  a  |---->|  b  |---->|  c  |----//
        +-----+     +-----+     +-----+
           ↓
2.
                 +-----+     +-----+
head ----------->|  b  |---->|  c  |----//
                 +-----+     +-----+
        +-----+    ↑
        |  a  |----+
        +-----+
3.
                 +-----+     +-----+
head ----------->|  b  |---->|  c  |----//
                 +-----+     +-----+
        +-----+
        |  a  |--//
        +-----+
```

#### 리스트 요소에 액세스하기

연결 리스트의 노드는 열차처럼 서로 연결되어 있다. 1번 칸에서 4번 칸으로 이동하기 위해서는 반드시 2번, 3번 칸을 거쳐서 가야 하듯이, 연결 리스트의 임의의 요소에 접근하기 위해서는 첫번째 노드와 해당 요소가 들어있는 노드 사이에 있는 모든 노드들을 한번씩 거쳐야 한다.

```cs
ListNode<TElem> node = head;
for (int i = 0; i < index; node = node.Next, i++);
//                         ^~~~~~~~~~~~~~~~
Console.WriteLine(node.Data);
```
